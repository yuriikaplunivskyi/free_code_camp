Система числення base-2, або двійкова система, це спосіб запису чисел, в якому використовуються лише два числа: 0 і 1. Кожне число в цій системі називається біт.

Уявімо, що у вас є коробки, і кожна коробка може містити або 0, або 1. Коробки розташовані одна за одною зліва направо. Права коробка - це “одиниці”, наступна зліва - “двійки”, потім “чотирі”, “вісім” і так далі. Кожна наступна коробка в два рази більша за попередню.
| Base-10 | Base-2 |
| ------- | ------ |
|    0    |  0     |
|    1    |  1     |
|    2    |  10    |
|    3    |  11    |
|    4    |  100   |
|    5    |  101   |
|    6    |  110   |
|    7    |  111   |
|    8    |  1000  |
|    9    |  1001  |
|    10   |  1010  |
Отже, якщо ви хочете записати число 1, ви просто покладете 1 в коробку “одиниці”, а всі інші коробки залишите порожніми (0). Це буде виглядати так: 1.

Якщо ви хочете записати число 2, ви покладете 1 в коробку “двійки”, а всі інші коробки залишите порожніми (0). Це буде виглядати так: 10.

Якщо ви хочете записати число 3, ви покладете 1 в коробку “двійки” і 1 в коробку “одиниці”. Це буде виглядати так: 11.

Якщо ви хочете записати число 4, ви покладете 1 в коробку “чотирьох”, а всі інші коробки залишите порожніми (0). Це буде виглядати так: 100.

Якщо ще складно, то спростимо пояснення .Уявімо, що у вас є коробки для іграшок. Кожна коробка може містити або 0 іграшок, або 1 іграшку. Коробки розташовані одна за одною зліва направо. 

| Коробка | Значення |
| ------- | -------- |
| Права   | Одиниці  |
| Середня | Двійки   |
| Ліва    | Чотирі   |

Отже, якщо ви хочете записати число 1, ви просто покладете 1 іграшку в коробку для "однієї" іграшки, а всі інші коробки залишите порожніми (0 іграшок). Це буде виглядати так: `1`.

Якщо ви хочете записати число 2, ви покладете 1 іграшку в коробку для "двох" іграшок, а всі інші коробки залишите порожніми (0 іграшок). Це буде виглядати так: `10`.

Якщо ви хочете записати число 3, ви покладете 1 іграшку в коробку для "двох" іграшок і 1 іграшку в коробку для "однієї" іграшки. Це буде виглядати так: `11`.

Якщо ви хочете записати число 4, ви покладете 1 іграшку в коробку для "чотирьох" іграшок, а всі інші коробки залишите порожніми (0 іграшок). Це буде виглядати так: `100`.


Біти часто групуються в октет, який є 8-бітним набором, відомим як байт. Байт може представляти будь-яке число від 0 до 255. Ось значення розміщення кожного біта в байті: 
|128 | 64 | 32 | 16 | 8 | 4 | 2 | 1|
Оскільки біти часто групуються в байти, часто можна побачити двійкові числа, представлені в групах по вісім, іноді з провідними нулями. Наприклад, число 52 можна представити як 110100, або 00110100 з провідними нулями. Ось як це розбивається зі значеннями розміщення: 
|128 | 64 | 32 | 16 | 8 | 4 | 2 | 1|
|0 |  0 |  1 |  1 | 0 | 1 | 0 | 0|


Уявімо, що у вас є 8 коробок для іграшок, розташованих в ряд. Кожна коробка може містити або 0 іграшок, або 1 іграшку. Кожна коробка має своє "значення", яке збільшується вдвічі, коли ми переходимо вліво. Ось як це виглядає:

| Коробка | Значення |
| ------- | -------- |
| 1       | 1        |
| 2       | 2        |
| 3       | 4        |
| 4       | 8        |
| 5       | 16       |
| 6       | 32       |
| 7       | 64       |
| 8       | 128      |

Тепер, якщо ви хочете записати число 52 за допомогою цих коробок, ви маєте розподілити 52 іграшки між коробками так, щоб сума "значень" коробок з іграшками дорівнювала 52. Ось як це виглядає:

| Коробка | Значення | Іграшка |
| ------- | -------- | ------- |
| 1       | 1        | 0       |
| 2       | 2        | 0       |
| 3       | 4        | 1       |
| 4       | 8        | 0       |
| 5       | 16       | 1       |
| 6       | 32       | 1       |
| 7       | 64       | 0       |
| 8       | 128      | 0       |

Як бачите, коробки 3, 5 та 6 містять іграшки, а їхні "значення" (4 + 16 + 32) складають 52. Це записується як двійкове число `00110100`, де `1` вказує на наявність іграшки в коробці, а `0` - на її відсутність.


##Рекурсія
```javascript
const countDownAndUp = (number) => {
  console.log(number);

  if (number === 0) {
    console.log("Reached base case");
    return;
  } else {
    countDownAndUp(number - 1);
    console.log(number);
  }
};

3
2
1
0
Reached base case
1
2
3
```
1. Зворотній відрахунок: Коли ви викликаєте функцію в середині самої себе (як countDownAndUp в цьому коді), це називається рекурсією. Рекурсія може бути трохи складною для розуміння, але ви можете уявити її як стек коробок: кожен новий виклик функції додає коробку на вершину стека. Коли ви досягаєте базового випадку (в цьому випадку, коли число дорівнює 0), ви починаєте видаляти коробки з вершини стека. Це і є “зворотній відрахунок” - ви повертаєтесь назад через кожен виклик функції, який ви зробили.
2. Базовий випадок: Базовий випадок в рекурсії - це умова, яка припиняє рекурсію. Це як “дно” стека коробок. Ви знаєте, що досягли базового випадку, коли більше немає коробок для додавання. В цьому коді базовий випадок - це коли number === 0. Коли це стає істинним, функція припиняє виклик самої себе і починає “зворотний відрахунок”.

Kоли ви викликаєте функцію в середині самої себе (як countDownAndUp в цьому коді), вона не завершується, поки не досягне базового випадку (в цьому випадку, коли число дорівнює 0). Після цього вона починає “повертатися назад” через кожен виклик функції, який ви зробили.

Отже, коли ви бачите зворотний відрахунок (1 2 3), це відбувається тому, що після того, як countDownAndUp досягла базового випадку і повернулася, вона продовжує виконання з місця, де вона зупинилася. Це означає, що вона виконує рядок console.log(number); для кожного виклику функції, який було зроблено. Це і є “очищення стеку”.